// Code generated by "enumgen"; DO NOT EDIT.

package signature

import (
	"errors"
	"log"
	"strconv"
	"strings"

	"goki.dev/enums"
)

var _LevelValues = []Level{0, 1, 2, 3}

// LevelN is the highest valid value
// for type Level, plus one.
const LevelN Level = 4

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _LevelNoOp() {
	var x [1]struct{}
	_ = x[LevelFail-(0)]
	_ = x[LevelWarn-(1)]
	_ = x[LevelInform-(2)]
	_ = x[LevelIgnore-(3)]
}

var _LevelNameToValueMap = map[string]Level{
	`LevelFail`:   0,
	`levelfail`:   0,
	`LevelWarn`:   1,
	`levelwarn`:   1,
	`LevelInform`: 2,
	`levelinform`: 2,
	`LevelIgnore`: 3,
	`levelignore`: 3,
}

var _LevelDescMap = map[Level]string{
	0: ``,
	1: ``,
	2: ``,
	3: ``,
}

var _LevelMap = map[Level]string{
	0: `LevelFail`,
	1: `LevelWarn`,
	2: `LevelInform`,
	3: `LevelIgnore`,
}

// String returns the string representation
// of this Level value.
func (i Level) String() string {
	if str, ok := _LevelMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the Level value from its
// string representation, and returns an
// error if the string is invalid.
func (i *Level) SetString(s string) error {
	if val, ok := _LevelNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _LevelNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type Level")
}

// Int64 returns the Level value as an int64.
func (i Level) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the Level value from an int64.
func (i *Level) SetInt64(in int64) {
	*i = Level(in)
}

// Desc returns the description of the Level value.
func (i Level) Desc() string {
	if str, ok := _LevelDescMap[i]; ok {
		return str
	}
	return i.String()
}

// LevelValues returns all possible values
// for the type Level.
func LevelValues() []Level {
	return _LevelValues
}

// Values returns all possible values
// for the type Level.
func (i Level) Values() []enums.Enum {
	res := make([]enums.Enum, len(_LevelValues))
	for i, d := range _LevelValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type Level.
func (i Level) IsValid() bool {
	_, ok := _LevelMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Level) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Level) UnmarshalText(text []byte) error {
	if err := i.SetString(string(text)); err != nil {
		log.Println(err)
	}
	return nil
}

var _SigFormValues = []SigForm{0, 1, 2}

// SigFormN is the highest valid value
// for type SigForm, plus one.
const SigFormN SigForm = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _SigFormNoOp() {
	var x [1]struct{}
	_ = x[SigFormPAdES-(0)]
	_ = x[SigFormJAdES-(1)]
	_ = x[SigFormUnknown-(2)]
}

var _SigFormNameToValueMap = map[string]SigForm{
	`SigFormPAdES`:   0,
	`sigformpades`:   0,
	`SigFormJAdES`:   1,
	`sigformjades`:   1,
	`SigFormUnknown`: 2,
	`sigformunknown`: 2,
}

var _SigFormDescMap = map[SigForm]string{
	0: ``,
	1: ``,
	2: ``,
}

var _SigFormMap = map[SigForm]string{
	0: `SigFormPAdES`,
	1: `SigFormJAdES`,
	2: `SigFormUnknown`,
}

// String returns the string representation
// of this SigForm value.
func (i SigForm) String() string {
	if str, ok := _SigFormMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the SigForm value from its
// string representation, and returns an
// error if the string is invalid.
func (i *SigForm) SetString(s string) error {
	if val, ok := _SigFormNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _SigFormNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type SigForm")
}

// Int64 returns the SigForm value as an int64.
func (i SigForm) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the SigForm value from an int64.
func (i *SigForm) SetInt64(in int64) {
	*i = SigForm(in)
}

// Desc returns the description of the SigForm value.
func (i SigForm) Desc() string {
	if str, ok := _SigFormDescMap[i]; ok {
		return str
	}
	return i.String()
}

// SigFormValues returns all possible values
// for the type SigForm.
func SigFormValues() []SigForm {
	return _SigFormValues
}

// Values returns all possible values
// for the type SigForm.
func (i SigForm) Values() []enums.Enum {
	res := make([]enums.Enum, len(_SigFormValues))
	for i, d := range _SigFormValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type SigForm.
func (i SigForm) IsValid() bool {
	_, ok := _SigFormMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i SigForm) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *SigForm) UnmarshalText(text []byte) error {
	if err := i.SetString(string(text)); err != nil {
		log.Println(err)
	}
	return nil
}

var _SignaturePolicyTypeValues = []SignaturePolicyType{0, 1, 2}

// SignaturePolicyTypeN is the highest valid value
// for type SignaturePolicyType, plus one.
const SignaturePolicyTypeN SignaturePolicyType = 3

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _SignaturePolicyTypeNoOp() {
	var x [1]struct{}
	_ = x[SignaturePolicyTypeNoPolicy-(0)]
	_ = x[SignaturePolicyTypeAnyPolicy-(1)]
	_ = x[SignaturePolicyTypeImplicitPolicy-(2)]
}

var _SignaturePolicyTypeNameToValueMap = map[string]SignaturePolicyType{
	`SignaturePolicyTypeNoPolicy`:       0,
	`signaturepolicytypenopolicy`:       0,
	`SignaturePolicyTypeAnyPolicy`:      1,
	`signaturepolicytypeanypolicy`:      1,
	`SignaturePolicyTypeImplicitPolicy`: 2,
	`signaturepolicytypeimplicitpolicy`: 2,
}

var _SignaturePolicyTypeDescMap = map[SignaturePolicyType]string{
	0: ``,
	1: ``,
	2: ``,
}

var _SignaturePolicyTypeMap = map[SignaturePolicyType]string{
	0: `SignaturePolicyTypeNoPolicy`,
	1: `SignaturePolicyTypeAnyPolicy`,
	2: `SignaturePolicyTypeImplicitPolicy`,
}

// String returns the string representation
// of this SignaturePolicyType value.
func (i SignaturePolicyType) String() string {
	if str, ok := _SignaturePolicyTypeMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the SignaturePolicyType value from its
// string representation, and returns an
// error if the string is invalid.
func (i *SignaturePolicyType) SetString(s string) error {
	if val, ok := _SignaturePolicyTypeNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _SignaturePolicyTypeNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type SignaturePolicyType")
}

// Int64 returns the SignaturePolicyType value as an int64.
func (i SignaturePolicyType) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the SignaturePolicyType value from an int64.
func (i *SignaturePolicyType) SetInt64(in int64) {
	*i = SignaturePolicyType(in)
}

// Desc returns the description of the SignaturePolicyType value.
func (i SignaturePolicyType) Desc() string {
	if str, ok := _SignaturePolicyTypeDescMap[i]; ok {
		return str
	}
	return i.String()
}

// SignaturePolicyTypeValues returns all possible values
// for the type SignaturePolicyType.
func SignaturePolicyTypeValues() []SignaturePolicyType {
	return _SignaturePolicyTypeValues
}

// Values returns all possible values
// for the type SignaturePolicyType.
func (i SignaturePolicyType) Values() []enums.Enum {
	res := make([]enums.Enum, len(_SignaturePolicyTypeValues))
	for i, d := range _SignaturePolicyTypeValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type SignaturePolicyType.
func (i SignaturePolicyType) IsValid() bool {
	_, ok := _SignaturePolicyTypeMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i SignaturePolicyType) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *SignaturePolicyType) UnmarshalText(text []byte) error {
	if err := i.SetString(string(text)); err != nil {
		log.Println(err)
	}
	return nil
}

var _SigScopeTypeValues = []SigScopeType{0, 1}

// SigScopeTypeN is the highest valid value
// for type SigScopeType, plus one.
const SigScopeTypeN SigScopeType = 2

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the enumgen command to generate them again.
func _SigScopeTypeNoOp() {
	var x [1]struct{}
	_ = x[SigScopeTypeFull-(0)]
	_ = x[SigScopeTypePartial-(1)]
}

var _SigScopeTypeNameToValueMap = map[string]SigScopeType{
	`SigScopeTypeFull`:    0,
	`sigscopetypefull`:    0,
	`SigScopeTypePartial`: 1,
	`sigscopetypepartial`: 1,
}

var _SigScopeTypeDescMap = map[SigScopeType]string{
	0: ``,
	1: ``,
}

var _SigScopeTypeMap = map[SigScopeType]string{
	0: `SigScopeTypeFull`,
	1: `SigScopeTypePartial`,
}

// String returns the string representation
// of this SigScopeType value.
func (i SigScopeType) String() string {
	if str, ok := _SigScopeTypeMap[i]; ok {
		return str
	}
	return strconv.FormatInt(int64(i), 10)
}

// SetString sets the SigScopeType value from its
// string representation, and returns an
// error if the string is invalid.
func (i *SigScopeType) SetString(s string) error {
	if val, ok := _SigScopeTypeNameToValueMap[s]; ok {
		*i = val
		return nil
	}
	if val, ok := _SigScopeTypeNameToValueMap[strings.ToLower(s)]; ok {
		*i = val
		return nil
	}
	return errors.New(s + " is not a valid value for type SigScopeType")
}

// Int64 returns the SigScopeType value as an int64.
func (i SigScopeType) Int64() int64 {
	return int64(i)
}

// SetInt64 sets the SigScopeType value from an int64.
func (i *SigScopeType) SetInt64(in int64) {
	*i = SigScopeType(in)
}

// Desc returns the description of the SigScopeType value.
func (i SigScopeType) Desc() string {
	if str, ok := _SigScopeTypeDescMap[i]; ok {
		return str
	}
	return i.String()
}

// SigScopeTypeValues returns all possible values
// for the type SigScopeType.
func SigScopeTypeValues() []SigScopeType {
	return _SigScopeTypeValues
}

// Values returns all possible values
// for the type SigScopeType.
func (i SigScopeType) Values() []enums.Enum {
	res := make([]enums.Enum, len(_SigScopeTypeValues))
	for i, d := range _SigScopeTypeValues {
		res[i] = d
	}
	return res
}

// IsValid returns whether the value is a
// valid option for type SigScopeType.
func (i SigScopeType) IsValid() bool {
	_, ok := _SigScopeTypeMap[i]
	return ok
}

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i SigScopeType) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *SigScopeType) UnmarshalText(text []byte) error {
	if err := i.SetString(string(text)); err != nil {
		log.Println(err)
	}
	return nil
}
